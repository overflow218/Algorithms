/*
leetcode 1611번

이게 생각해보면 f(n) = x로 고정된 상태임. 
글고 숫자가 10억 범위까지 들어올 수 있는데 커지는거 생각하면 20억 까지 될수 있다고 봐야지. 
그러면 int 자료형에 다 담기는 정도네 

1번, 2번 반복하면서 진행해주면 될 거 같긴한데 그러면 너무 많다. 
생각을 좀 해보면
11 이 연속으로만 붙어있어야 왼쪽의 1을 없애고 옆으로 갈 수 있딴 말이지.. 
11, 110, 1100, 11000, .... 꼴만 -> 10, 100, 1000, 10000.. 꼴로 바꿀수 있다는 말이지

000 에서 
100 만들려면
000 -> 001 -> 011 -> 010 -> 110 -> 111 -> 101 -> 100

00에서 10 만들기
00 -> 01 -> 11 -> 10
즉 n번째 자리를 뒤집기 위해선 2 ^ n - 1의 횟수가 필요하다 이말임. 

100을 000 으로 만드는 것도 같은 이치라고 할 수 있제
100 -> 101 -> 111 -> 110 -> 010 -> 011 -> 001 -> 000 

그러면 앞에서부터 쭉 반복하면 되겠지.. 
근데 여기서 문제는 
뒤에께 00이 아니라는게 문제죠
그러면 어떻게 하느냐?
없애버리면 되지... 
즉 n = 2^k 꼴이면 쉬운데, n = 2^k + x 꼴인 경우 어려움. 
거기다가 문제는 2^k + x 인 경우가 횟수가 더 작다는게 문제지

f(x) = x -> 0으로 만드는데 필요한 횟수라고 하자. 
f(2 ^ k) = 2 ^ k - 1 이라고 했음. 
f(2 ^ k + x) = ???
근데 2 ^ k 를 2^k + x로 바꾸려면 x 만 붙여주면 되짆아. 
이거는 f(x)와 같음. 
그러면 2^k 는 0으로 가는데 2^k + x 보다 f(x) 번 만큼의 연산이 더 필요한게 되는거임
즉 f(2^k) = f(2 ^ k + x) + f(x)가 되는거네

*/

class Solution {
public:
    int pow[32] = {0};
    int find(int n)
    {
        if(n == 0) return 0;
        for(int i = 31; i >= 0; i--)
        {
            if(n & (1 << i))
            {
                return pow[i] - find(n ^ (1 << i));
            }
        }
        return -100000;
    }
    int minimumOneBitOperations(int n) {
        pow[0] = 1;
        for(int i = 1; i < 31; i++)
        {
            pow[i] = pow[i - 1] * 2 + 1;
        }
        return find(n);
    }
};
